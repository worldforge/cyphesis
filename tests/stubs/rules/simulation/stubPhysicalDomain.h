// AUTOGENERATED file, created by the tool generate_stub.py, don't edit!
// If you want to add your own functionality, instead edit the stubPhysicalDomain_custom.h file.

#ifndef STUB_RULES_SIMULATION_PHYSICALDOMAIN_H
#define STUB_RULES_SIMULATION_PHYSICALDOMAIN_H

#include "rules/simulation/PhysicalDomain.h"
#include "stubPhysicalDomain_custom.h"

#ifndef STUB_PhysicalDomain_PhysicalDomain
//#define STUB_PhysicalDomain_PhysicalDomain
   PhysicalDomain::PhysicalDomain(LocatedEntity& entity)
    : Domain(entity)
    , m_terrain(nullptr)
  {
    
  }
#endif //STUB_PhysicalDomain_PhysicalDomain

#ifndef STUB_PhysicalDomain_PhysicalDomain_DTOR
//#define STUB_PhysicalDomain_PhysicalDomain_DTOR
   PhysicalDomain::~PhysicalDomain()
  {
    
  }
#endif //STUB_PhysicalDomain_PhysicalDomain_DTOR

#ifndef STUB_PhysicalDomain_isEntityVisibleFor
//#define STUB_PhysicalDomain_isEntityVisibleFor
  bool PhysicalDomain::isEntityVisibleFor(const LocatedEntity& observingEntity, const LocatedEntity& observedEntity) const
  {
    return false;
  }
#endif //STUB_PhysicalDomain_isEntityVisibleFor

#ifndef STUB_PhysicalDomain_getVisibleEntitiesFor
//#define STUB_PhysicalDomain_getVisibleEntitiesFor
  void PhysicalDomain::getVisibleEntitiesFor(const LocatedEntity& observingEntity, std::list<LocatedEntity*>& entityList) const
  {
    
  }
#endif //STUB_PhysicalDomain_getVisibleEntitiesFor

#ifndef STUB_PhysicalDomain_getObservingEntitiesFor
//#define STUB_PhysicalDomain_getObservingEntitiesFor
  std::vector<LocatedEntity*> PhysicalDomain::getObservingEntitiesFor(const LocatedEntity& observedEntity) const
  {
    return std::vector<LocatedEntity*>();
  }
#endif //STUB_PhysicalDomain_getObservingEntitiesFor

#ifndef STUB_PhysicalDomain_addEntity
//#define STUB_PhysicalDomain_addEntity
  void PhysicalDomain::addEntity(LocatedEntity& entity)
  {
    
  }
#endif //STUB_PhysicalDomain_addEntity

#ifndef STUB_PhysicalDomain_removeEntity
//#define STUB_PhysicalDomain_removeEntity
  void PhysicalDomain::removeEntity(LocatedEntity& entity)
  {
    
  }
#endif //STUB_PhysicalDomain_removeEntity

#ifndef STUB_PhysicalDomain_applyTransform
//#define STUB_PhysicalDomain_applyTransform
  void PhysicalDomain::applyTransform(LocatedEntity& entity, const TransformData& transformData, std::set<LocatedEntity*>& transformedEntities)
  {
    
  }
#endif //STUB_PhysicalDomain_applyTransform

#ifndef STUB_PhysicalDomain_refreshTerrain
//#define STUB_PhysicalDomain_refreshTerrain
  void PhysicalDomain::refreshTerrain(const std::vector<WFMath::AxisBox<2>>& areas)
  {
    
  }
#endif //STUB_PhysicalDomain_refreshTerrain

#ifndef STUB_PhysicalDomain_toggleChildPerception
//#define STUB_PhysicalDomain_toggleChildPerception
  void PhysicalDomain::toggleChildPerception(LocatedEntity& entity)
  {
    
  }
#endif //STUB_PhysicalDomain_toggleChildPerception

#ifndef STUB_PhysicalDomain_isEntityReachable
//#define STUB_PhysicalDomain_isEntityReachable
  bool PhysicalDomain::isEntityReachable(const LocatedEntity& reachingEntity, float reach, const LocatedEntity& queriedEntity, const WFMath::Point<3>& positionOnQueriedEntity) const
  {
    return false;
  }
#endif //STUB_PhysicalDomain_isEntityReachable

#ifndef STUB_PhysicalDomain_installDelegates
//#define STUB_PhysicalDomain_installDelegates
  void PhysicalDomain::installDelegates(LocatedEntity& entity, const std::string& propertyName)
  {
    
  }
#endif //STUB_PhysicalDomain_installDelegates

#ifndef STUB_PhysicalDomain_operation
//#define STUB_PhysicalDomain_operation
  HandlerResult PhysicalDomain::operation(LocatedEntity& e, const Operation& op, OpVector& res)
  {
    return *static_cast<HandlerResult*>(nullptr);
  }
#endif //STUB_PhysicalDomain_operation

#ifndef STUB_PhysicalDomain_tick
//#define STUB_PhysicalDomain_tick
  void PhysicalDomain::tick(double t, OpVector& res)
  {
    
  }
#endif //STUB_PhysicalDomain_tick

#ifndef STUB_PhysicalDomain_queryCollision
//#define STUB_PhysicalDomain_queryCollision
  std::vector<CollisionEntry> PhysicalDomain::queryCollision(const WFMath::Ball<3>& sphere) const
  {
    return std::vector<CollisionEntry>();
  }
#endif //STUB_PhysicalDomain_queryCollision

#ifndef STUB_PhysicalDomain_observeCloseness
//#define STUB_PhysicalDomain_observeCloseness
  boost::optional<std::function<()>> PhysicalDomain::observeCloseness(LocatedEntity& entity1, LocatedEntity& entity2, double reach, std::function<void()> callback)
  {
    return *static_cast<boost::optional<std::function<()>>*>(nullptr);
  }
#endif //STUB_PhysicalDomain_observeCloseness

#ifndef STUB_PhysicalDomain_removed
//#define STUB_PhysicalDomain_removed
  void PhysicalDomain::removed()
  {
    
  }
#endif //STUB_PhysicalDomain_removed

#ifndef STUB_PhysicalDomain_createDomainBorders
//#define STUB_PhysicalDomain_createDomainBorders
  void PhysicalDomain::createDomainBorders()
  {
    
  }
#endif //STUB_PhysicalDomain_createDomainBorders

#ifndef STUB_PhysicalDomain_buildTerrainPages
//#define STUB_PhysicalDomain_buildTerrainPages
  void PhysicalDomain::buildTerrainPages()
  {
    
  }
#endif //STUB_PhysicalDomain_buildTerrainPages

#ifndef STUB_PhysicalDomain_buildTerrainPage
//#define STUB_PhysicalDomain_buildTerrainPage
  TerrainEntry& PhysicalDomain::buildTerrainPage(Mercator::Segment& segment)
  {
    return *static_cast<TerrainEntry*>(nullptr);
  }
#endif //STUB_PhysicalDomain_buildTerrainPage

#ifndef STUB_PhysicalDomain_childEntityPropertyApplied
//#define STUB_PhysicalDomain_childEntityPropertyApplied
  void PhysicalDomain::childEntityPropertyApplied(const std::string& name, const PropertyBase& prop, BulletEntry& bulletEntry)
  {
    
  }
#endif //STUB_PhysicalDomain_childEntityPropertyApplied

#ifndef STUB_PhysicalDomain_entityPropertyApplied
//#define STUB_PhysicalDomain_entityPropertyApplied
  void PhysicalDomain::entityPropertyApplied(const std::string& name, const PropertyBase& prop)
  {
    
  }
#endif //STUB_PhysicalDomain_entityPropertyApplied

#ifndef STUB_PhysicalDomain_getMassForEntity
//#define STUB_PhysicalDomain_getMassForEntity
  float PhysicalDomain::getMassForEntity(const LocatedEntity& entity) const
  {
    return 0;
  }
#endif //STUB_PhysicalDomain_getMassForEntity

#ifndef STUB_PhysicalDomain_getCollisionFlagsForEntity
//#define STUB_PhysicalDomain_getCollisionFlagsForEntity
  void PhysicalDomain::getCollisionFlagsForEntity(const BulletEntry& entry, short& collisionGroup, short& collisionMask) const
  {
    
  }
#endif //STUB_PhysicalDomain_getCollisionFlagsForEntity

#ifndef STUB_PhysicalDomain_sendMoveSight
//#define STUB_PhysicalDomain_sendMoveSight
  void PhysicalDomain::sendMoveSight(BulletEntry& bulletEntry, bool posChange, bool velocityChange, bool orientationChange, bool angularChange, bool modeChanged)
  {
    
  }
#endif //STUB_PhysicalDomain_sendMoveSight

#ifndef STUB_PhysicalDomain_processMovedEntity
//#define STUB_PhysicalDomain_processMovedEntity
  void PhysicalDomain::processMovedEntity(BulletEntry& bulletEntry, double timeSinceLastUpdate)
  {
    
  }
#endif //STUB_PhysicalDomain_processMovedEntity

#ifndef STUB_PhysicalDomain_updateVisibilityOfDirtyEntities
//#define STUB_PhysicalDomain_updateVisibilityOfDirtyEntities
  void PhysicalDomain::updateVisibilityOfDirtyEntities(OpVector& res)
  {
    
  }
#endif //STUB_PhysicalDomain_updateVisibilityOfDirtyEntities

#ifndef STUB_PhysicalDomain_updateObservedEntry
//#define STUB_PhysicalDomain_updateObservedEntry
  void PhysicalDomain::updateObservedEntry(BulletEntry& entry, OpVector& res, bool generateOps )
  {
    
  }
#endif //STUB_PhysicalDomain_updateObservedEntry

#ifndef STUB_PhysicalDomain_updateObserverEntry
//#define STUB_PhysicalDomain_updateObserverEntry
  void PhysicalDomain::updateObserverEntry(BulletEntry& bulletEntry, OpVector& res)
  {
    
  }
#endif //STUB_PhysicalDomain_updateObserverEntry

#ifndef STUB_PhysicalDomain_applyNewPositionForEntity
//#define STUB_PhysicalDomain_applyNewPositionForEntity
  void PhysicalDomain::applyNewPositionForEntity(BulletEntry& entry, const WFMath::Point<3>& pos, bool calculatePosition )
  {
    
  }
#endif //STUB_PhysicalDomain_applyNewPositionForEntity

#ifndef STUB_PhysicalDomain_getTerrainHeight
//#define STUB_PhysicalDomain_getTerrainHeight
  bool PhysicalDomain::getTerrainHeight(float x, float y, float& height) const
  {
    return false;
  }
#endif //STUB_PhysicalDomain_getTerrainHeight

#ifndef STUB_PhysicalDomain_updateTerrainMod
//#define STUB_PhysicalDomain_updateTerrainMod
  void PhysicalDomain::updateTerrainMod(const BulletEntry& entry, bool forceUpdate )
  {
    
  }
#endif //STUB_PhysicalDomain_updateTerrainMod

#ifndef STUB_PhysicalDomain_processDirtyTerrainAreas
//#define STUB_PhysicalDomain_processDirtyTerrainAreas
  void PhysicalDomain::processDirtyTerrainAreas()
  {
    
  }
#endif //STUB_PhysicalDomain_processDirtyTerrainAreas

#ifndef STUB_PhysicalDomain_applyDestination
//#define STUB_PhysicalDomain_applyDestination
  void PhysicalDomain::applyDestination(double tickSize, BulletEntry& entry, const PropelProperty* propelProp, const Vector3Property& destinationProp)
  {
    
  }
#endif //STUB_PhysicalDomain_applyDestination

#ifndef STUB_PhysicalDomain_applyPropel
//#define STUB_PhysicalDomain_applyPropel
  void PhysicalDomain::applyPropel(BulletEntry& entry, btVector3 propel)
  {
    
  }
#endif //STUB_PhysicalDomain_applyPropel

#ifndef STUB_PhysicalDomain_calculatePositionForEntity
//#define STUB_PhysicalDomain_calculatePositionForEntity
  void PhysicalDomain::calculatePositionForEntity(ModeProperty::Mode mode, BulletEntry& entry, WFMath::Point<3>& pos)
  {
    
  }
#endif //STUB_PhysicalDomain_calculatePositionForEntity

#ifndef STUB_PhysicalDomain_processWaterBodies
//#define STUB_PhysicalDomain_processWaterBodies
  void PhysicalDomain::processWaterBodies()
  {
    
  }
#endif //STUB_PhysicalDomain_processWaterBodies

#ifndef STUB_PhysicalDomain_createCollisionShapeForEntry
//#define STUB_PhysicalDomain_createCollisionShapeForEntry
  std::shared_ptr<btCollisionShape> PhysicalDomain::createCollisionShapeForEntry(LocatedEntity& entity, const WFMath::AxisBox<3>& bbox, float mass, btVector3& centerOfMassOffse)
  {
    return *static_cast<std::shared_ptr<btCollisionShape>*>(nullptr);
  }
#endif //STUB_PhysicalDomain_createCollisionShapeForEntry

#ifndef STUB_PhysicalDomain_transformRestingEntities
//#define STUB_PhysicalDomain_transformRestingEntities
  void PhysicalDomain::transformRestingEntities(BulletEntry& entry, const WFMath::Vector<3>& posTransform, const WFMath::Quaternion& orientationChange, std::set<LocatedEntity*>& transformedEntities)
  {
    
  }
#endif //STUB_PhysicalDomain_transformRestingEntities

#ifndef STUB_PhysicalDomain_plantOnEntity
//#define STUB_PhysicalDomain_plantOnEntity
  void PhysicalDomain::plantOnEntity(BulletEntry& plantedEntry, BulletEntry* entryPlantedOn)
  {
    
  }
#endif //STUB_PhysicalDomain_plantOnEntity

#ifndef STUB_PhysicalDomain_applyTransformInternal
//#define STUB_PhysicalDomain_applyTransformInternal
  void PhysicalDomain::applyTransformInternal(BulletEntry& entry, const WFMath::Quaternion& orientation, const WFMath::Point<3>& pos, const WFMath::Vector<3>& impulseVelocity, std::set<LocatedEntity*>& transformedEntities, bool calculatePosition)
  {
    
  }
#endif //STUB_PhysicalDomain_applyTransformInternal

#ifndef STUB_PhysicalDomain_scheduleTick
//#define STUB_PhysicalDomain_scheduleTick
  Atlas::Objects::Operation::RootOperation PhysicalDomain::scheduleTick(LocatedEntity& entity)
  {
    return *static_cast<Atlas::Objects::Operation::RootOperation*>(nullptr);
  }
#endif //STUB_PhysicalDomain_scheduleTick

#ifndef STUB_PhysicalDomain_tick_handler
//#define STUB_PhysicalDomain_tick_handler
  HandlerResult PhysicalDomain::tick_handler(LocatedEntity& entity, const Operation& op, OpVector& res)
  {
    return *static_cast<HandlerResult*>(nullptr);
  }
#endif //STUB_PhysicalDomain_tick_handler

#ifndef STUB_PhysicalDomain_isWithinReach
//#define STUB_PhysicalDomain_isWithinReach
  bool PhysicalDomain::isWithinReach(BulletEntry& reacherEntry, BulletEntry& targetEntry, float reach, const WFMath::Point<3>& positionOnQueriedEntity) const
  {
    return false;
  }
#endif //STUB_PhysicalDomain_isWithinReach

#ifndef STUB_PhysicalDomain_calculateVisibilitySphereRadius
//#define STUB_PhysicalDomain_calculateVisibilitySphereRadius
  float PhysicalDomain::calculateVisibilitySphereRadius(const BulletEntry& entry) const
  {
    return 0;
  }
#endif //STUB_PhysicalDomain_calculateVisibilitySphereRadius


#endif