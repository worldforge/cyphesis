seq is not restored.

Properties added by requirePropertyClass and perhaps related functions
are not getting installed or applied.

Currently properties are being installed early before all Entity IDs have been
restored. Need to delay. This will be a problem if there are Entity properties
around linking things together by pointers.

Make operations that depend on newId generation failable, so that a
database issue does not cause an assertion to fail.

Make sure property names are limited to 32, and also class names to the same
length. Make this 32 limit a compile time constant. Also check ruleset name
length.

Fix abort() in newId() when Database connection is down. Probably best done
with an ID pool.

Make non-value related members of a TerrainModProperty mutable, so
they can be modified without having to get a non-const pointer.

modProperty should handle setting the flag_unsent flag on properties.

Central Knowledge, available to all NPCs without being taught.

Add SIGINT handler to cycmd to cancel tasks.

Doxygen TODO lists!

All the in-place property mods are not handling apply()
Should this be done in Update()?
updateOperation could handle setting clearing the per_clean flag, the
entity_clean flag, and apply the properties.

add_map really has no code in it
update_map contains very little and is probably obsolete as it never gets
called
Review hooks and see if they really are needed.
Note that:
 in sight_create_operation all that is being checked for is if we created it
 If we did create it, this is going to be a special interest to any mind
 so we could look at supporting it in the core base class.

 in sight_move_operation we are looking for changes to the inventory
 and taking ownership. Could this again be supported in the base code?

 Both sight_move and sight_create update the map via the Python API
 when this could be more efficiently done in the C++ if the op
 handler wasn't overriden. Why not assume the python handler does not
 override?

 The overall concept of overriding from scripts and also from handlers
 probably needs to be looked at.

Num property to implement stuff. Only works if it is installed as a class
property, otherwise does nothing. (Resets to one).
Value of one means nothing is sent.
Installing class causes instance property to be placed, but install is
not called on it.

Purge stackable.

Fix the stamina property, currently commented out.

Clear set ops out of tasks (in Character) and combat.
Can probably get rid of the hard Task pointer while at it.

In Plant.cpp a lot of properties are directly updated. Need to review
whether apply() and install have to be called on them.

Add an entity flag to indicate that the entity has been modified in
the python API, and on returning to core context an update needs to
be triggered.

Move requireSpecificProperty() and have it check on the defaults for
a default value.

Update Thing::updateProperties so it checks all properities to see whether
they've been written to the database. May need to trigger a database update.

Re-work the python wrappers to handle generating the necessary update flags
when modifying an IG entity. Complete different from the wrapper behavior
in the mind, which should probably no implement setattr at all.
It may need to generate Update or perhaps even Set operations as necessary.

Use a property flag for removing properties.

Fix up OutfitProperty to work with the modified API and conventions.
It can't really be a class property as it has entity refs, so I guess
it must be instance only. install() might like TerrainModPropery()
detect the case of a class version, and ensure that it is added as
an instance property.

Cutting down simulation cost when nothing is watching.
Gorgious. Send out a ping, and get back an estimate. at the simplest level
the simulation can continue, but decline to send out update ops. Kick off
an update in response to any subsequent look ops. Seq is being incremented
so Appearance will tell minds they need an update.

Make the overall movement model configurable. If a flat world is all that is
needed, there is no need to add more. In a fantasy MMO there is probably very
little need for more. There is a strong link here between this and the need
for persistence. If we only need character persistence, we can't really deal
with them having something other than the world as their LOC.

Define an operatoin which went sent returns the count of entities which
can see something, so we can suspend simulation.

cyclient wants ops back in response to its creates. If we don't automatically
make Creator perceptive, how can we make this happen?

If properties are responsible for their own serialisation, the represations
can be much more efficient.

Re-enable mapping of character to account.

Design away to make only the starting POS and ORIENATION of an entity
storable.

Sort out enable_persitence. Purge the old code.

TerrainModProperty needs state, so it must be an instance property.
This can be handled in ::instal() once class properties are flagged.

Use database to allow characters to go offline.

Location is stil adding bbox data to RootEntity or MapType representations.
Stop, as this should be handled by the property.

Make sure all the places properties are set use one single way to do
it, ensuring the right calls get made to set it up.

Some entities (Character) may end up updating a class property and
then we get an error when the Update op arrives for an undiscovered
property. This also corrupts the class.

requireSpecificProperty installs new properties. Need to make sure it does
it correctly.

Think carefully about what happens when EntityBuilder::installFactory
calls Inheritance::addChild. If add child returns NULL, there
was something wrong with the factory installation and it should fail.

isSimple() and isSolid() should be entity flags, once the collision
stuff is sorted.

Modify client code which inherits from Entity so it uses LocatedEntity
or summink instead, removing the need for ClientPropertyManager.

Fix the insert properry count. Incremented in the wrong place.

Use return value of Property::get to ensure we are not storing
worthless data in the properties table.

Check use of the property manager in Character when adding status property.

Implement flag_class in EntityBuilder.

Once things are sorted for the new property mechanism, with install and apply
implemented, 

insertEntity and updateEntity are returning the bool result of scheduleCommand
incorrectly.

Perhaps we can use property flags for Update ops, rather then the cludgy
going through strings?

Remove assertion from CorePropertyManager that a property called objtype
can't be created.

Implement transient to avoid Database traffic.

Make sure the select fallback code handles congested and busy ok.

Sort out http connection with a configurable port.

Make it so classes inherit python scripts, now that the factory is independant
of atlas type name.

Need a property flag to indicate that it is new, rather than just dirty.

Make update interval has jitter on it, so we don't get spikey load.

Types should have integer IDs. Bootstrap type queries with well know IDs for basic types.

Admin Creator avatatar gets destroyed once it is no longer connected, but
it then calls Connection::removeObject() despite the Connection being
long gone.

Use a broadcast cost heuristic to determine how often movement updates should
done for an entity.

Migrate everything out of BaseEntity until nothing remains, at which point
rename it to IdentifiedRouter or something like that, inheriting from
Identified. LocatedEnity should eventually not inherit from it.

rename removePlayer to something more suitable.

Once defaults work, handle pulling from defaults in the SpecificProperty
templates.

Fix the issue of leaked sigc++ connections, as connections to tool.containered
are added, but never disconnected.

Fix the rest of defaults on the TypeNode.

Use onFoo() methods to implement some of the signals we expect.

Quaternion and BBox need to be more like Vector3D and Point3D, and all 4 should
really be in physics.

In a compound object, that contains sub-objects, COMPONENTS can be like
CONTAINS, but COMPONENTS do not have a separate existence. They are destroyed
if the entity is destroyed, and do not have globally addressable IDs.
They can still be represented by Entity, but won't be in the global ID
dictionary. This leads to the idea of a component property interface whcih
abstracts looking up component IDs. An accompanying stamp can reduce the
frequency with which clients need to inspect the components, as they should
change very infrequently.

SEQ is not being used in the memmap code, as it is not being set.

Re-write plant using properties when we can write scripts for property
handlers.

Character::m_rightHandWield needs to stop being hard coded. Should
be really easy to do. Make it a dynamic property always, add install
it as required.

B&W style village construction. Nursery, plus schools for training.

Re-factor abstract factories to be called Kits, and high level factories that
assemble arrangements of objects as Builders. Concrete factories can then
use the suffix factory.

Put locks around writing the user config file.

Move bbox out of Location, and make it a soft property only.

Add instance configuration support to tools and clients.

Add setting for config file.

openID, libopkele
echo -n 'username:phpMyID:password' | openssl md5

Separate functionality for removing from container, and adding to new
container.

Modify security in NPCMind so we can do the goals without broadcasting the
talk ops. Use the TO on the Talk op to determine if this is an admin op,
so that clients can redirect ops easily. Need to verify that checking
Sound.FROM is the only reason interlinguish functions need the op. It
may be possible to get rid of passing in orignal_op completely.

New Atlas-C++ has no inheritance tree, just one class in Objects. Instead
it has function to create the instances, which create the defaults object
if required, pass it in, and return a smartptr to an instance from the pool.
Convenience versions of these function could take op arguments for operations,
or IDs or the like for entities.

Activations should use type nodes perhaps.

Check if SECONDS is set before using it? All ops in basemind should do this.

Add an argument to Location::addToEntity which specifies which need to be
set as zero values of they are not set. This should make it easier to
deal with the concept of POSless entities, and perhaps entities without
velocity. Would be nice to get rid of any situation where something has
zero velocity, as this is annoying to have to check for.

Fix new PythonArithmeticScript() from being leaked. ArithmeticFactory(124)
Shader surfaces are being leaked from TerrainProperty::set(130)

Switch over to using Atlas::Objects as the fundamental unit in the objects
code. Needs AtlasFileLoader to be converted over. This is the best first step
before we have a type tree. Done. Now get rules loading from the Database once
more, as the database code insists on MapType. Could we store the attribute
defaults in the Atlas default type thingy? Would this cause problems?
So, when we are creating a Atlas::Objects::Anonymous instances, need to
be able to set up the default object so it just works. A barrier to this being
really useful is the way Atlas-C++ currently handles defaults. It does not send
them at all. Need to modify so it sends them if they have been flagged on
the defaults object. Default to not flagging, and then modify sending behavoir.
Think about using an inherited interface to prevent calling getName()
which might cause a crash.

Core cyphesis daemon is very simple and robust. Never crashes. It launches
and monitors and number of child daemons. Simplest configuration is a single
child daemon. It reads and parses the config mostly for checking purposes.
Write common infrastructure which can check the contents of the config
for errant values, and report them. Use the current help data structures.
There should in the eventual configuration be one watcher daemon, one
simulation daemon, one persistor daemon, and one spatial processing daemon per
CPU. Simulation should be network bound, peristence should be disk bound, and
spatial should be CPU bound.

Experiment with factory base classes. Can we have a base class for BaseEntity,
inherit from it overriding with a function that returns Entity.

Datagram classes in skstream, Address classes in skstream. Datagram can be
sent to an address, without re-encoding. Datagram can be treated as stream.
Address can encapsulate getaddrinfo results, or stand alone endpoints.

There need to be two different filters on movement. The first pass should
determine what is possible given the desired input. The second should
determine side effects of the movement. Can we really separate them, given
that the side effects modify the effort and possibility of the movement?

Blocking movement thingies are going to have to go. Handling move ops should
just schedule the move. We pass to some collision subsystem, and then send
the result once the result it back.

Make IGEntityExerciser succeed in stimulating the Create op.
Make IGEntityExerciser succeed in stimulating the Move op.

Create a simple class that fully encapsulates having a python script in
a general way, which can then be used by entity, task, statistics etc.

EntityFactory has got really convoluted. Try and verify that the same things
are done when a tool is updated as when it is loaded. May be good to break
things down into smaller functions.

script_factory->refreshClass is called before populateFactory(). Seems weird.
Surely the script might have been changed? If it has, what causes it to be
loaded?

Fill out auto activation op stuff. Now that operations is automatic,
need to ensure children inherit the behavior as well as the value, which
requires some work on the activations.

In EntityFactory, we should abort a task install if the target does not exist.

Add unit tests to make sure rule install order with multiple dependencies
is okay.

Write a task to beat down fire with shovel.

Specify contents of the house in the class rule, rather than using the script
to create it. Contained entity data format again, just like blueprint.
CONSTITUANTS?

Add a transient property which indicates that something does not last, and
should not be persisted. This would allow most of the seed scripts to be
removed.

There is a chance something could get screwed up in waitingRules.
If something depends on two classes, and the second is not present the first
time it fires, m_waitingRules will get modified mid iteration, and then
the waiting item will get removed despite the fact that is has not been
installed.

When a task cannot be installed because of pre-reqs, record the error so
it can be reported.

Push to remove the world class, making it all more driven by data behavior.

POS can't change in Dig and Delve, so make them irrelevant if its not the right
kind of terrain.

Add range check to Dig and Delve, and see if it can be done more generally.

Re-write goals for butcher so they now interact correctly with the task
implementation.

GetOp is not part of IG, so illustrates for OOG dispatch to be different from
IG.

Apply behavior to newly created skellys. Now that the mind classes have been
removed, skeletons need goals to do anything.

Implement blocking rules until all associated rules can be verified so
tasks can't get installed without their activation ops and classes existing.

self.progress seems to start out at -2 in Slice. Uninitialised?

Add a way to handle per-host config in a single config file.

Fix parameter lookup in varconf.

Add a call to Atlas-C++ which takes a bit field of attribute bits, and returns
a bitfield of attribute bits that was requested but not present. Reduces
error checking complexity loads.

Pig seller seems to assume he is being given coins when actually they
are being handed round by other people.

Look up in Python Nutshell and read up on ref-counting + exceptions. Read
whole section on embedding.

ServerRouting owns accounts currently, so have it encapsulate the whole
database thing. Check if the findAccount test is a good reason not to do
this.

metaserver needs to reinitialise if bind is lost.

Make sure autopackage uses /var/tmp rather than PREFIX/var/tmp

Instrument BaseMind/MemMap to detect mutiple additions of the same thing
to the same mind.

Make it easier to use cypasswd to elevate privs.

Add ability to create other types of avatar.

Investigate -static-libgcc for partially static version of binaries for
distribution.

autopackage should start server

Set up python environment during test, so they import from the source tree.

Find out why locks up when it can't load ruleset.

Add a new kind of programmable mind, for babysitting player characters.

Provide python access to the game config.

Prevent soft attributes being set with the names of known properties.

Set name from client.

Setting attributes needs to be re-done more complex. Reporting divided
into scopes, and reporting done based on what really happened, not what
the Set wanted to happen.

Move the stuff that generates vast quantity of test Atlas data into
its own class, so other things can use it.

Complete the work on property exercising tests.

Fix python code which uses PyMem_DEL to use PyObject_Del which is the
right thing now.

Minds are getting properties from the core factory, because it is now accessed
as a singleton. This cannot stand.

Add a humanoid base class, putting default character bbox and the like in
there, plus decays="skull".

If I attach a property that listens out for delete ops, and creates things,
do the returned ops still work okay? Ie does the deleted entity stick
around long enough for the operation to get dispatched, even though it has
been removed from the world map. If so, could use this to handle creating
corpse, bones etc.

Implement some kind of helper mechanism which monitors ops going to the client
and if some match a certain template, it sends hints in the form of emotes.

Move metabolism into a property, ensuring that Character becomes a cleaner
class. Implement death better, creating a skeleton with a named skull.
Mod the lich code to use the name on the skull when creating the skeleton.

Take another look at the scheme used in mind code to purge entities
it thinks are bad.

Add an operation to account allowing the client to add a mind to its
Character. When a Character has internal and external mind, ops from the
internal mind should go only to the externalMind.

Add an option to put a python console on stdio. See PyRun_InteractiveOneFlags
to see an example of a functio which takes a line, and executes it in
the way that the interactive interpretter does.

Implement GUISE property.

Atlas::Message::Element has TYPE_NONE, so we have a conceivable way
to signal clearing of an attribute. Basically only possible soft attributes
unless we want to make the Atlas::Objects code hideous. If we are going to
find a way to signal this to the client, we need to add it to Atlas-C++.

How do we clear a Property if it is specified by Update arg, but is no
longer set to anything? Need a way for force it.

Make updateProperties read-only perhaps? Needs to clean out properties.

In GuiseProperty, need to ensure that  Set operation is simply a trigger
for an update, so we can do things efficiently. A signal triggered
by destruction or container change should trigger a Set(guis={}) which
once it gets to the SetOperation handler gets its arg re-written, I guess
the only option is the complete value.

Strip most operations out of the mindFooOperation() interface, as all soft
ops now go via scripts, if at all.

Make sure all properties override correctly. Check const.

Look at PyOplist and see if it would be better to embed the object rather than
have a pointer.

Consider, can we pre-fetch and cache the python object involved in calling a
hook?

Plough field, grow veggies. Carrot turnip.

Add code to EntityPropertytest to cover setting by ID.

Can we make client connection code more generic, getting rid of the
nasty merged TCP / UNIX stuff, and sharing code between tools and client.
Perhaps even totally generic for server and client.

Add log rotation /etc/logrotate.d/foo to rpm.

Improve pig death handling. Death is effectively just removing the mind
state, so do so. Also think about disconnecting the incoming side
of external mind. Perhaps interact in some way with the movement state?

Ad physical constraints system, which if move op comes, it is filtered
or transformed by it. For example, in a structure, elements of that
structure would be contrained so that they translated move ops into
move ops of their parent entity, the structure itself. This should be
possible using the generic idea of properties that handle operations,
and gives us a use case example for how a given property might need
to filter or override an operation.

datagram notes: see skstream TODO. Idea: When a broadcast op arrives at
the Connection, route it to an object handling datagram comms for a given
set of clients, and it caches the object, and notes the target address.
It then builds a pool of target addresses for the cached op as the
op is broadcast around the clients, and then later, in the socket loop
code, it then handles sending the data out. Alternatively it could 
serialise when it first gets the op, and cache the serialised data
in the stream, noting the identity of the operation so that it can
resend it. As long as it holds the operation smart pointer, no
other operation can arrive with the same address, although another one
later may easily have the same address once the smartptr releases to the
memory pool. As soon as another op arrives for transmission, it should be
okay to release the previous one, as it is not coming back.

Why handle sight_create_operation in NPCMind when the implementation in
BaseMind does everything fine, and we can handle the ownership in the
add_map() hook?

Should Unseen be handled in BaseMind -> MemMap rather than taking the
hit in the python code?

Replace hasAttrFlag which isDefaultFoo for efficiency.

rootWorldId should be a parameter to WorldRouter, not hardcoded.

Make ServerRouting pluggable by replacing with NodeRouting subclass, or
something, which might contain more stuff to handle being a node in a
distributed server. Might also be necessary to replace WorldRouter, which
will be no problem, as everything currently refers to it by its base class.

Fix appear disappear for instantaneous edit move ops.

map and list attributes on python objects are a problem, because the
wrappers copy then in getattr, meaning that modifications are lost.

Key player owned property, like houses and mounts should perhaps be listed
in the account charlist, and thus in the connection objects list, allowing
direct external control.

Read readline docs, and sort out good way of ensuring output does
not mess up prompt.

Make sure client can't get the impression it has taken over a non character
entity.

In next series, PARENTS on Atlas objects should be a vector.

Make logging task rotate the tree to flat over a tick interval, which
removes the issue of the progress glitching half way through the task,
as long as the rate is set to zero for the tick while the tree falls.

When dispatching a unicast op`to an entity, check if its
flags change for zero to non-zero as a result, and if so, add it to a queue
to be commited to database later. This even allows for immediate effect
ops to be grouped into a transaction perhaps. It might be necessary or
apropriate to guarantee that immediate ops are dispatched immediatly
rather than returning to idle if a certain number of ops occur.

Implement stacking basics with the active code in a property, and wrappers
in a base C++ class. Once properties can directly handle ops, less of a
problem, and the base class goes away. Stacking is explicit and driven by
mind and client.

Remove scriptSubscribe functions.

Get rid of Entity::m_attributes by making a SoftProperty class for adding
arbitrary properties to entities. Saves some lookups I think.

Combine and Divide need to ensure the atomicity of the operation, ensuring
that if creation fails, the whole thing fails. Without its not safe. Should
either allow changes to the original entities to be specified?

Add a task to cut things in half, to be used on materials.
Take a unit vector vertically upwards, transform by the entities transform
and use the resulting vector to determine which way is up. This axis and
the axis which closely matches the direction of the acting entity to the
centre of the material will be used. The position of the cut is defined by
the position clicked on, and the width of the cut should be defined in the
script somewhere.

Add trenching rule, and perhaps think about a generic task that can allow
someone to help someone else do the task they are doing.

Add property system, with property classes registered with entity factory,
and stored in the entity class object. Implementation should avoid looking up
excessively in dictionaries at entity instance time. Instead the work should
be done at class creation time. In the long term, properties defined by
scripts should be required. Reduce the role of C++ inheritance in what
properties things have, and instead put more on the bass class, and perhaps
use flags to indicate whether they are in use.

Make use of wrapTask().

Hmm, when logging out an account, the characters from that account, do
they remain in the connections dictionary? Is this bad?

Separate out IG_OP_SWITCH from OOG_OP_SWITCH. Very little overlap.
IG Does not have: GET, ERROR, INFO, LOGIN, LOGOUT, USE??? (should fix),
                  ADD, CUT
OOG Does not have: ACTION, APPEARANCE, DISAPPEARANCE, COMBINE, DELETE,
                   DISAPPEARANCE, DIVIDE, ERROR, INFO, MOVE, SIGHT,
                   SOUND, TOUCH, USE, WIELD, ADD, ATTACK, BURN,
                   CHOP, CUT, EAT, NOURISH, SETUP, TICK, UPDATE

The w2m*Operation code does only 2 things:
  It checks for Setup and Tick ops whether they are for the mind, which
  we can do in the mind code.

  It filters based on drunkness.
Both can go, removing the mechanism altogether.

STUN can be used for NAT detection. Useful? UDP only. Still useful.

Perhaps it should be possible to specify class data about the hard coded
classes in data/*,xml.

In order to store class related stuff without having to store it on
the instance, might need to have a type class which each Entity has
a pointer to. Should it also be possible to specifiy different statistics
classes in data/*.xml?

Add a base class for all active mobile characters in mason.xml, and set
up the essential statistics values. I am not sure but there may still be
issues with specifying class inheritance in the rules.

Test account and avatar creation from client when database is down.

Once SEQ has replaced STAMP in Atlas-C++, use it instead of serialno
in Tick op args.

Note that tp_new should do essential non-repeatable initialisation, like
calling in place constructor. Current newFoo() functions in the Python
API code do not cause the types tp_new or tp_init to be called. Need to
work out why, and see if changes are needed.

Add media for boots, bowl, cow, flower, hat, knife, leaf, loaf, statue, stool,
and longtable

Need to work out a sane way to handle udp socket for sending to multiple
clients quickly and efficiently.

Add short varconf args.

Make gobos rob after ganking.

Perhaps entities can have an Atlas Anonymous attached to avoid newly
constructing one every time look is called. Ref counting objects mean
no copy is required.

Add pickaxes, and trowels, and knowledge about tools to the tool merchant.

Sequence of events when database goes down:

2006:01:22 17:58:23 NOTICE DATABASE: FATAL:  terminating connection due to administrator command
2006:01:22 17:58:23 ERROR Got database query complete when no query was pending
2006:01:22 17:58:37 ERROR newId(): Database query error.
2006:01:22 17:58:37 ERROR DATABASE: server closed the connection unexpectedly
        This probably means the server terminated abnormally
        before or while processing the request.
cyphesis: WorldRouter.cpp:288: virtual Entity* WorldRouter::addNewEntity(const std::string&, const Atlas::Objects::Entity::RootEntity&): Assertion `!id.empty()' failed.
2006:01:22 17:58:37 CRITICAL Aborted

Notice there is often a deley before the third event, but even so it might
be possible to bridge a gap in database availability with some kind of
local ID generation. Anyway, clearly we are notified that the database
is going down quite some time before it causes, so we should be able to do
something about trying to reconnect. Might need to separate the
server Database Idler from the Database socket, so the idler can manage
attempting to re-connect.

Code using "unit_vector_to.." is probably only working in the same
container, and should probably be fixed to work with distance_to().

In operation_new, and other places where keywords are used, iterate
over the keywords rather than checking for a number of values. Should be
more efficient, especially when the kwds are empty. Also allows errors to
be detected better.

Make more things emit suitable action operations, especially picking up,
dropping, and combat.

Character.statistics from python needs to use the statistics script to wrap
it.

Should be able to use PyModule_New() to add submodules to existing modules,
rather than the messy dictionary hack now used for some.

When checking type of a python object, use PyObject_TypeCheck() new in 2.2
especially when inheritance is involved.

With the new way python types are defined, it may be possible to get
rid of separate wrapper and script objects, and have the script inherit from
the wrapper directly. The C++ pointer would have to be added to the structure
later, once the script object which inherits from the wrapper base class
has been returned. This means no access to the core object allowed during
__init__(). Problem may arrise when checking the type of the script to
see if it inherits from the wrapper class. Is this possible?

Py_Location now holders pointer to owning Entity if any. Now we need to
incref and decref in the important places.

We need to be able to check if things are visible from goal scripts, so
a MemEntity version of the Entity wrapper is required.
This would mean we could make buy_thing goal expire when seller goes out
of sight.

The getTickAddtion calculation is almost certainly redundant. We almost
certainly worked in out in previous call to generateMove().

Add face() to buy_livestock and related goals.

Modify mindMap so that entities are visible if they get updated.

Once Script returns an int which differentiates between an error, and
a missing method, then mind reference in PythonMindScript can got, and
error can be reported in BaseMind or somewhere similar.

Once stored python wrapper is done, the wrapper can be specialised for
Character so that task related code is exposed.

Don't do the same bullshit help every time the user clicks on a helping NPC.
Bugs: Crash when fire burns. (sear)

Look up upgrading the python API usage to 2.2 spec. In particular
look at generic attribute handling, PyType_Ready, inheritance etc.
Method doc strings.

Use getProperty to implement a surface property, and integrate into the
height adjustment code.

Do any Python types with have an _attr member initialise it before
they have to in setattr? Py_Entity/Thing used to.

Character jumps to the bottom when swimming.
Jumping to bottom is because when the character rises above water
the movement code assumes it is walking, and then height is constrained 
accordingly to terrain.
Character/Pedestrian needs to handle surface properties, so it can't walk
up steep slopes. Also need to handle jump, to get down steep slopes the quick
way.

Lobby accounts still indexed on string IDs. Good or bad?

Should ImmutableProperty inherit from Property, or the other way round so
that implementations of get and add can be shared? Yeah.

Write test for SignalProperty.

In cycmd, use flag to indicate when output is written, so it is possible to
identify when at prompt, and move to next, and also possible to more cleanly
redraw prompt, rather than forcing it every time codec->poll() is called.

ForbiddenThingFactory::duplicateFactory could return PersistantThingFactory
so its possible to add more abstract factories.

In order to have attribute defaults inherit from parent classes,
the code must first store the unmodified defaults direct from the rule
in a separate place. Its main attributes should then be the result of merging
those with its parent. This ensures that the result is always right, without
having to walk all the way up to GameEntity. It is also makes propagating
modified attributes down the tree easier, as long as a factory stores
a list of its children. This means we have two compelling reasons why the
parent factory needs to be available when the child is being installed.

Handle SQL escaping of attributes encoded string before persisting.

Implement tracking terrain surface, and preventing climbing of steep terrain.

Implement data driven gui dialogues, in Sear and perhaps equator.

<map>
  <list name="parents><string>dialogue</string></list>
  <string name="label">Dialogue</string>
  <list name="contents">
    <map>
      <list name="parents"><string>vbox</string></list>
      <list name="contents">
        <map>
          <list name="parents"><string>label</string></list>
          <string name="label">This is a dialogue</string>
        </map>
        <map>
          <list name="parents"><string>hbox</string></list>
          <list name="contents">
            <map>
              <list name="parents"><string>button</string></list>
              <string name="label">Okay</string>
            </map>
            <map>
              <list name="parents"><string>button</string></list>
              <string name="label">Cancel</string>
            </map>
          </list>
        </map>
      </list>
    </map>
  </list>
<map>


        -------------------------Dialogue------------------------
        |                                                       |
        |   A dialogue                                          |
        |                                                       |
        |     --------------------     -------------------      |
        |     |      Okay        |     |     Cancel      |      |
        |     --------------------     -------------------      |
        |                                                       |
        ---------------------------------------------------------

Are attributes inherited? I think not. Need to be.

Carefully use flags to check for illegal stuff from client/mind ops.

Walking army of the undead, daily.

Spatial iterators, for map have a reference to a const_iterator, and filter
while incrementing. Iterate between space(bot_left, top_right)  and end().

Don't update POS in database if VELOCITY is non-zero.

strlen.com

Predators should now use combat code to defeat prey before eating, and
then Eat op on character should only work on incapacitated characters.

A bunch of stuff in Character::externalOperation can go if we don't care
about ops having serialnos.

Move contents of mindUseOperation to UseOperation, and have mindUseOperation
filter ops like it should.

Combat system needs to depend on character stats, armour, clothing and
weapon at very least. Probably need a class to encapsulate important
processed stat information for a character. This makes it harder to
have a fully configurable combat system.

Define new class Volume which contains the set of points and normals
required by the collision code. Cache the volume, and bounding radius
of entities in Location. bounding radius is very easy. Add a course
collision check based on bounding radius.

Not sure destination based movement is working right if destination pos
changes due to LOC change.

Fix collisions. Leaving needs to be the inverse of entering, and this
implicitly means we need to check collisions with the parents' children.
We could also probably do with a very course check to make the whole thing
cheaper.

Collision code would be more reliable if collisions were check with
current parent's siblings, as well as entities siblings.

Make sure all Property classes have add(Entity)

Task tick ops need to embed the ident of the task, to ensure a replacement
does not cause a problem.

Modify Attack handler so it is the attackee that creates the task object,
so attacking a pointless target has no effect without any smarts required
in mindAttackOperation().

We can probably block all ops to mind when its unconcious from
the Character class.

Make Connect and Attack standard Atlas op.

Sort out issue where carrying a living tree kills people. Caused by
eat op from tree.

Attribute modifiers should be a new low-level primitive on Entity,
like property. They should be done before attributes are set from data,
but after default attributes are set. Scale control variables should
be assumed to be 1 initially for the purposes of scaling.
A function like merge should be used to apply scalars. It needs to be
able to copy the modded data into Atlas for reporting back to the client.

Fix dodgey collision code which causes structures with complex parts to cause
tight loop conditions.

It should be possible to make trees fall so that they are parallel with
the terrain, if a mechanism is available to determine normal of the
supporting surface.

Does it matter if World gets a delete op when status becomes < 0? It
shouldn't, as the delete op should be ingored, so World does not need
a Set op implementation.

Sort out a way to move world functionality into a script.

On #python talk to deltab TFK or #pyrex.

When reloading a python module, try to load it even if it didn't load before.

Prevent forbidden attribute from leaking through in move ops from client.

Re-code chickens so they flee on contact, rather than on sight.
Fix lych and skellys.

Implement swimming, which requires constraining the updated pos in the movement
code to be sure of getting the right Z. Try and do some direction stuff in
the sear interface.

Clean up old movement code, get rid of Movement::m_velocity, and perhaps
m_orient.

When getMoveUpdate is first called in moveMoveOperation, it doesn't really
want an operation, just an update of the position.

Add swimming to Pedestrian. Try and add floating by default to non aquatic
creatures.

Move Create handler from Entity into Thing, as everything IG inherits from
Thing.

Make an Atlas encoding to describe basic layers.

Implement buying clothes to be worn. Garment base class, use wield operations
to use.

Implement spawnpoints, and separate mason and werewolf locations.

Make sure python object references aren't leaked in script factories.

Implement subsystems on server object. Allow Admin to fetch the subsystems,
like "configuration", "policy" etc.

policy should include things like:
   Account creation on the fly.
   Number of characters per account.
   Number of character played at the same time per account.
   Visibility of player on character and character on player.
   Character removal from world on logout.

Installed types from the client need to be persisted in the database.

Create harness device which is a number of entities connected by ropes.
Consists of hook, and a number of ends to be held by people. Each end is
attached by a rope entity to the thing to be moved. To attach the hook,
it is wielded and used on the target. Each person the wields and uses
their ends. When enough people pull, the target moves. Vector of travel
is the average of the distances to the people pulling.

Add use of pickaxe to split rocks. Initial rock in ground could be huge,
and require splitting, or heavy equipment to move. Rock can be shaped into
stone billet for use in building using a chisel.

Add operation Increment which allows deltas to be made to attributes.
Important for atomicity in delayed events. Propagated as Sight(Set).

Grass should dry out.
Earth and sand should return to the soil.
Sand can be made into a sandy area using a tamper.
Digging earth could create a field area.
Might need to notify entities when their parent changes.

Code up projectile movement as a first test of entity movement.

Sort out so lobby had a real ID.

Code up allowing accounts to create rooms, and guilds.

Optimise down the number of calls to iterator::end in mindUseOperation

Add a reach attribute to tools which tells the client how far the NPC must
be from the target before they can use it on something.

Fix Creator::LookOperation so that it doesn't return anything if no
match can be found. Also it should probably not accept ops with TO already
set.

Add cydumprules to the man pages.

Clean out Python operation API, as its full of unused and useless functions.

Slave or Peer servers need to negotiate types at startup.

Make the butcher more helpful to n00bs.

Implement a Tool base class which eliminates the need for tool scripts - 
handles the necessary op conversions driven by data.

Make sure stamp is updated in MemMap and checked, and implement Unseen.

Implement trivial combat, and code up a bunny bashing quests for the hard
of thinking.

Add ticker callback mechanism to WorldRouter, which calls callback whenever
a tick is required. Will reduce the cost of the op queue by making it smaller,
and should be cheaper than tick ops. Needs to be carefully designed. Can handle
stuff like one-shots, as well as regular ticks.

Spec an op similar to use, but for things which are just used by themselves,
like buttons, valves, levers etc. Target has operations=[...] just the same,
and the arg of the new op specifies what op to do, but the Character just
needs the one gateway.

Implement Task interface, which represent enduring tasks, including combat.
Could also include destination based movement. Task needs a name, and an
accessor for it, so it can be used as a private Property.

When calling NPCMind.face when buying an item, for some reason the velocity
of Pedestrian is valid and set to a weird value. This is because the
target position where the merchant wants to be is at a different z value
from where the character ends up. This is a general problem with moving
to pre-defined positions.

We could move the loop into ServerRouting, rather than CommServer.
Rename CommServer::idle to CommServer::poll or something like that.
Perhaps we don't even need idle any more. Idle objects would then
be owned by ServerRouting rather than CommServer. CommServer would
then be almost fully generalised. In order to lose the reference to
ServerRouting in CommServer, the listeners would have to have this reference
instead - move the specialisation into the listeners.

Does sightFooOperation etc. in BaseMind.h have to be virtual? I think not.
Yes it does, as its overriden in some client code.

CONTAINS could be some kind of spatial set of buckets for efficiency
when doing collision detection, but if this is not to be true for all entities
then the mechanism for modifying CONTAINS needs to be virtualised, and
made a method on the container/LOC. If the spatial stuff is to work then
the entity needs to be removed while it still has its old coords, and added
to its new container with its new coords.

We should be able to look at the attributes of an python instance to
determine what operations it needs to be subbed to. It doesn't have a
dictionary, but it does have the methods as attributes.

Make sure that goals involving movement don't issue a move op unless its
necessary. ie check to see if we are already moving in the right direction.

Fix Movement/Pedestrian to handle destination based movement where LOC
changes. Just use distanceTo as the velocity vector.

The spot_something goal is a hack - need something better. Probably need
some kind of Knowledge about target entity. Give the Knowledge predicate
as an argument to spot_something(), and add Knowledge with that predicate
once something has been spotted. For example
spot_something('lumber', 'spotted_lumber')

mind.things in NPCMind seems to be completely based on the name attribute,
though it seems like it would make more sense for it to use type some of
the time.

Each entity could have a Mode object which controls how its movement/position
is simulated, including the effect of gravity etc. This would be associated
with a mode string.

If the character moves an entity into another similar entity, then
we should create a Pile. This can be detected in mindMoveOp().

Currently no mechanism to inform client/mind that the ID they just
specified is gone. Need to think of something, and make sure mind
deals correctly. Something like Unseen operation.

Can Property mechanism be used to handle raw Python data as properties?

Sort out the issue of un-initialised POS, ORIENTATION and BBOX in the
database.

MemEntity needs some kind of reference flag/count if a python object
is holding a reference. Probably as well to ref-count all IG entities,
then we can hold a reference in the op queue, and avoid lookup up the
FROM at dispatch time. Would also allow entities to hold pointers.

Fix unit_vector_to in python interface to make sure it doesn't cause
a normalise() abort(). Probably re-write to use relativePosition() which
may need to be fixed to give the right direction. The correct direction
should be the coordinate space that the observer's position is in. It
is probably currently returning it in the entities local coords.

Stop creator characters for getting filed into the accounts_entity_ent
table.

Transforming with an invalid quaternion creates an invalid vector or point.
We must not do it. See FIXME in WorldRouter.cpp.

Is it necessary to copy new_coords in Pedestrain::genMoveOperation()?

Sort out trees thrashing database. Postpone until we have done something
about database transactions.

Centralise serialno assigment on IG ops, checking for 0 to see if we should?

Sort out FIXME in Creator::operation().

Character creation should not fail if creating its bootstrap inventory fails.
Errors from coin creation are confusing clients.

Convert FormatedXMLWriter into a templat that can drive any Atlas codec.
Thus we can have any Atlas Codec output in formatted human readable form.
Formatter can be a generic non-template Brige that sits between Encoder
and Codec.

It might make sense to keep a pointer to the entity an operation is from
in the queue, if its available at the point when we store it. How do we
then make sure we don't hold bad references?

Report error properlly in MemEntity when clock skew is detected.

Try and avoid removing stuff from the mind as soon as its been added. Perhaps
by checking the iterator ID on insert?

Try out dynamic cast rather than string test to identify ops in WorldRouter.

It would probably be easier to move extraction of parents from a new entity
to world.addNewObject() to avoid duplication.

Use "REFERENCES foo ON DELETE CASCADE" SQL to make sure character table
relations are removed when a character is deleted, or an account is deleted.

So, we have skill, which is a way of mapping tool use into actions.
How about tasks, which are a way of giving persistence and state to actions?

Sort out deer animations.

Add grasing.

By adding a skill class to be referenced by character, and defining Teach 
(transfer skill) Sling (stop wielding tool, and place somewhere convenient)
we can have almost a complete system. Implicitly, the click action when a tool
is wielded is to use that tool.

Re-work the way PyEntity and PyMind are defined so the inheritence is
available, and open up the scope for exposing more directly the functionality
of other entity classes.

Stop creating new objects from causing so much activity. Perception of the
new object must be based on its visibility. Perception of its deletion
should also be limited. Implement LRU in mind.

Upsidedown chickens suck!

Use tool, Wield op and Use op.

Add beet.

Look at me Swimming!

Debug skellys.

Make lych move. Construct skeleton nearby.

Handle modifying bbox proportionally to parameters.

Linears and stuff.

Path finder based roads and stuff.

Create pig pen.

Generalise money_transfers in mind to store general information about
all transfers of ownership. Preferably in knowledge.

Make chickens afraid of wolf.

Make vis re-calculated on bbox change.

Make walking speed depend on height.

Make cyclient more robust about receiving random ops.

Implement spawn points in the EntityFactory.

Verify that the persistant code does not insert entities into the world with
invalid location data. It shouldn't.

Fix movement bug with destination based movement after collision. Ammend
find target to be derived from velocity.

Fix or get rid of cyphesis-setup

Fix usage of map.get in BaseMind and NPCMind

Make ExternalMind inherit from something higher that BaseMind. It has so
few features.

It may be possible to get rid of getXyz() (crappy absolute position)

Its really not necessary for WorldRouter and its base to be so virtual, or
inherit from BaseEntity. Get rid of that, shift all the serialno stuff into
base.

Add time to location, so we can stamp update time, and always calculate pos.

We can neglect to send appearance if we are about to send Sight Move.

distanceTo does not take into account orientation.

Sort out putting everything at terrain height. This may require some strange
stuff.

Invesitage interaction between mind/body WRT type. We shouldn't ever use
the type string in Atlas.

Get rif of Entity::m_name, and other related pointless static attrs.

Fix Entity::addToObject to be more efficient with contlist

Make the server easier to kill.

Enforce well-formed args and parents on IG ops centrally.

MemMap::add and MemMap::update are the same, identical. Eliminate this
sameness

Broadcast appearance on entity creation. Not that other Sight(Create())
bullshit.

Real sight ranges

Do minds delete stuff from memory? Replace Entity with a special class
for memory entities, includin some kind of LRU thingy.
Implement LRU culling to minds, only for things with empty contains.
MemMap::lookId should probably not be exposed to the python API

Add Restore op if required which does the same as Setup, but for restore.

Make sure we don't schedule database maintenence if its already doing it.

Add a search function to cycmd to search for entities by type or name.

There is probably a problem with getLocation bailing if LOC is not of the
data from the mind code's point of view.

Why the hell is there so much mind activity on database restore.

Take precautions to ensure multiple looks don't get stacked up in the MindMap.
Probably best done by making additionsById a map.

Add some simple sound op examples

Make Forest a non-solid bbox

Fix problem with vertical movement. (See BUGS)

Debug collision with sty.

Make cyphesis less reluctant to shutdown. Check for exit_flag in more
places.

Can we get a code size or performance improvement by passing in the result
list as part of the operation method call. The answer is yes, but the
further question is whether this will break anything. We can also stop
calling the script post dispatch, and call it before op dispatch instead,
giving a single call point, instead of loads of call points all the way
through the code. Problems:
  BaseMind: Blocks perception when it is asleep - this would be bipassed.
            Process Appearance in the C++ code, even if script takes it.
  Main script subscription process is bipassed, but this may well be ok
  and mean that we can remove scripts from the subscription mechanism
  completely.
  Character: Tick - some types of tick need to be processed in the core,
             even if others go to the script. Complicated processing.
             Why no script in nourish?
  Thing: Broadcasts a sight(create()) op in Setup, before calling script.

Think about how to deal with things that probably don't need persistance.
Seeds in particular. Flag in the rules?

Need to profile why startup takes so long - we are chewing a lot of ops.

Can we run our own RDBMS in the event that root access is not available.

Modify var dir for socket so it is actually the right place.

Run "SET autocommit TO 'off';" on connection to database, and run "COMMIT;"
every 30 seconds (or so).

Make database maintainance intervals configurable.

Sort out character relation so it has the right foreign key stuff.

Looks like zero collision time results in move then stop being sent
almost immediatly. Check for it, and send nothing. This may mean
re-ordering the movement code. Possibly checkCollisions needs
to be earlier.

Modify Movement and Pedestrian classes so they handle restricting an
entity to their parents constraints. In the case of Pedestrian, this
means walking on the ground.

Clean the database. Use VACUUM once an hour, and probably VACUUM ANALYSE
and VACUUM FULL each once per day. REINDEX may also be required.

Sort out socket address re-use, and lingering.

Long term, try and sort out the way object factories, scripts, and atlas
inheritance are handled, so they are a bit more coherant.

Modify the logging code so that it mangles script output a bit less.

Fix up python checks so they work with a prefix other than /usr

Is listen socket getting opened before it will accept or negotiate because
more work is being done before poll/select occurs.

Fix up cypasswd to allow creation of additional admin accounts.

Think about adding UPnP here or to skstream (or both)

Use PyInstance_New to create an instance given a class.

Use PyModule_AddObject(), PyModule_AddIntConstant(), and
PyModule_AddStringConstant() when setting up the python consts module.
(new in version 2).

Look at re-writing python API code to work with python GC

Look at using zipfiles to store entrie trees of python files for a ruleset.

Still plenty of python object leaks. Need to carefully see if references are
being handled right in the mind code.

Sort persisting world so things like its orientation are initialised correctly.
Either valid or invalid.

Implement constraints on entities, which have to be checked before movement
is allowed.

Add propper type engine.

Put in different high level exception catchers, to differentiate between
exceptions caused by a client, which should result in a kick, and bugs in game
which need to be logged.

Mind state is still utterly unpersisted, so creatures are waking up brain dead
- mind does not even get kick started with a setup op.

Putting an index on entity_ent.loc massively improves database loading
performance. Need to assess impact on runtime performance. Should definitly
consider putting this index in place permanently. Why is it that on some cases
this does not help? Indexes are not good for lots of instances of a small set
of values.

When deleting an entity, need to deal with reparenting its children in the
database.

Experiment with BEGIN / COMMIT blocks to reduce load on database. A
possibility is starting a transaction, and then commiting, delaying if their
are requests which have not yet been sent. This of course pre-supposes that
the mechanism for sending queries to the database asynchronously has
been done. It is probably acceptible to only accept queries that do not
return any tuples, and then the asyncronous recieve mechanism doesn't need
to worry about who wants the tuples.

General TODO

  Come up with a way to persist general attributes.

  Persist more complex things like geo stuff.

  Generalise and virtualise the collision code.

  Implement jump operation, which specifies target, and comes back with,
  a sight of a jump which has the starting velocity, and finish position.
  If the client sends only velocity, then something else happens. Add
  a method to Pedestrian to handle it.

  Add Feel as the counterpoint to Touch, as Sight is to Look.

  Implement piles.

  For entities which have a bbox, which other entities do not collide
  with, such as geo entities, provide a virtual methods which allows the
  collission code to check whether entities within this bbox should
  be moved into the bbox entity. Should work fine for irreguler shaped
  things, as long as bbox is kept up to date.

  Ensure that maxmass set in python has some effect in C++, and investigate
  other related attributes.

  Connecting to other server: Make class peer of CommClient called
  CommConnection or something which is basically the same, but implements
  connecting instead of accepting. Might even be able to merge the code
  in, or make it a template. Make object which inherits from Connection
  called ServerConnection which is created and linked to CommConnection
  which handles pushing operations from the other server into the
  WorldRouter. The question now is, how this is managed at the other end,
  and what is done with operaions generated by this server due to
  operations from the other one.

  Add suspend functionality, which stops the advance of time, and
  thus suspends all mind activity. Could also inhibit broadcasts. Effectively
  puts the server in bulk maintenance mode, from which NPCs should be
  removed. Should consider the effect this will have on NPC memory,
  and whether or not it can be rebootstrapped.

  Looking at contains attribute currently only applies sight ranges in
  world entity. Need to apply sight ranges in all entities.

  Once the subscription mechanism works, transfer its setup into the factories,
  and use it to inform the clients what op types are meaningful for object
  types.

  Fix the database so it handles updating entities. Need to actually lookup
  how this is done. Need to lock row if its being updated.

  Add services features, and test them in equator.

  Fully implement stackable objects.
  Use combine operation to deal with making more than one object into one.

  Add sending of touch op on collision.

Required for werewolf:

  Implement calendric time using WorldTime and DateTime classes, so nighttime
  and moons are properlly handled.

  Implement sleeping.

  Sort out a reasonable way of representing day and night to client. Look
  up info on Durals astronomy. Weather (clouds, snow, rain, thunder and
  lightening).

Required for mason:

  Create a skills system which the action is passed to, and the skill
  returns the resulting operation to the world. This skills system
  would be handling by the character class, in the mindXxxxOperation()
  methods. The skill would be an object with a reference back to the
  character it belongs to, and a method that is passed the action taking
  place. It would return operations to be passed to the world which carry
  out that action to the extent of the ability of the character. Some
  skills will just do nothing, like the ability to wave, or shout. or
  maybe the shout action could decide using a skill how loud the shout is.

  Implement the Mason raw materials.
  
Possible ideas:

  Add fully featured database persistance.

  Persistance system is naive right now. It does not take account of that
  fact that characters need minds, and it stores the world object.
  Persitance is now sorted so it loads the world hierarchicly, but
  it still does not handle minds and things. Problems with current
  code include velocity being stored, and bounding boxes not being
  recovered.
  Basic C++ code for supporting saving and loading of mind state is now
  in place, but support needs to be added into the Python NPCMind
  class to store the data it requires.
  Code is still required to store the state of the operation queue.
  Restoring of accounts from database requires re-connecting characters
  too.

  Get system working as an AI client to another server. This would also
  be a good time to get cyphesis working as a mindless server, without
  any AI code.

  Route finding for the AI. NPCs already have symbolic knowledge of places.
  All we need is a mechanism for describing that two places (or nodes) have
  a direct route between them, and then the mind can build a graph which
  allows them to find a route. We also need to provide a mechanism so that
  NPCs know about a particular entity. This can be done by sending a generated
  sight operation.

  Sort out collision detection wrt moving alongside an object in close
  proximity, and add CD for two moving objects. Basically we need sliding.
  along an object. This can be done by zeroing the velocity along
  the axis perpendicular to the collision. Obviously we need to add
  a mechanism for establishing which axis is perpendicular to the collision.
  This now works, but the direction the moving entity is facing is sometimes not
  modified.

  Modify map to make more use of stamp.
